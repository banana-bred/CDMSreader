var tipuesearch = {"pages":[{"title":" CDMSreader ","text":"CDMSreader {!README.md}","tags":"home","url":"index.html"},{"title":"asymtop_state – CDMSreader ","text":"type, public, abstract :: asymtop_state Corresponds to an asymmetric top molecule defined by Q = 23 without the hyperfine splitting,\nessentially averaged over F Components Type Visibility Attributes Name Initial integer, public :: dN Twice the rotational quantum number of the molecule as a rigid rotor integer, public :: dKa Twice the approximate projection of N on the A axis integer, public :: dKc Twice the approximate projection of N on the C axis real(kind=dp), public :: E The state energy real(kind=dp), public :: EinstA The total Einstein coefficient from this state real(kind=dp), public :: sigmaA2 Uncertainty in the Einstein A coefficient squared:","tags":"","url":"type/asymtop_state.html"},{"title":"asymtop_state_nohfs – CDMSreader ","text":"type, public, extends( asymtop_state ) :: asymtop_state_nohfs Already defined by asymtop state ! Components Type Visibility Attributes Name Initial integer, public :: dN Twice the rotational quantum number of the molecule as a rigid rotor integer, public :: dKa Twice the approximate projection of N on the A axis integer, public :: dKc Twice the approximate projection of N on the C axis real(kind=dp), public :: E The state energy real(kind=dp), public :: EinstA The total Einstein coefficient from this state real(kind=dp), public :: sigmaA2 Uncertainty in the Einstein A coefficient squared: integer, public :: degen The total hyperfine degeneracy of the state Σ(2F+1)","tags":"","url":"type/asymtop_state_nohfs.html"},{"title":"asymtop_state_hfs – CDMSreader ","text":"type, public, extends( asymtop_state ) :: asymtop_state_hfs Corresponds to an asymmetric top molecule defined by Q = 23 with the hyperfine splitting Components Type Visibility Attributes Name Initial integer, public :: dN Twice the rotational quantum number of the molecule as a rigid rotor integer, public :: dKa Twice the approximate projection of N on the A axis integer, public :: dKc Twice the approximate projection of N on the C axis real(kind=dp), public :: E The state energy real(kind=dp), public :: EinstA The total Einstein coefficient from this state real(kind=dp), public :: sigmaA2 Uncertainty in the Einstein A coefficient squared: integer, public :: dJ Twice the total angular momentum of the rotation (N) and the electron spin (S). integer, public :: dItot Twice the nuclear spin quantum number integer, public :: dF Twice the angular momentum from the rotation and electrons (J) and the nuclear spin (I).","tags":"","url":"type/asymtop_state_hfs.html"},{"title":"asymtop_transition – CDMSreader ","text":"type, public :: asymtop_transition Corresponds to a transition Components Type Visibility Attributes Name Initial type( asymtop_state_hfs ), public :: up Upper state type( asymtop_state_hfs ), public :: lo Lower stat real(kind=dp), public :: freq The frequency of the transition real(kind=dp), public :: EinstA The Einstein coefficient A real(kind=dp), public :: err The error integer, public :: dr Degrees of freedom integer, public :: gup Upper level degeneracy","tags":"","url":"type/asymtop_transition.html"},{"title":"CDMS_readline – CDMSreader","text":"public impure module subroutine CDMS_readline(funit, freq, err, EinstA, DR, ELO, GUP, TAG, qnfmt, qn, mol, io, skip, comment_char_in) Uses CDMSreader__types CDMSreader__system iso_fortran_env Read \"cat\" file from the CDMS contents into appropriate arrays, with the capability to skip lines that are well-commented or blank\nthe comment character defaults to \"#\", but can be set to anything not in the character NUMERIC also not whitespace Arguments Type Intent Optional Attributes Name integer, intent(in) :: funit real(kind=dp), intent(out) :: freq Frequency of the line real(kind=dp), intent(out) :: err Estimated or experimental error (999.9999 indicates error is larger) real(kind=dp), intent(out) :: EinstA The Einstein A coefficient integer, intent(out) :: DR Degrees of freedom in the rotational partition function (0 for atoms, 2 for linear molecules, and 3 for nonlinear molecules) real(kind=dp), intent(out) :: ELO Lower state energy in cm–1 integer, intent(out) :: GUP Upper state degeneracy integer, intent(out) :: TAG Species tag or molecular identifier. A negative value flags that the line frequency has been measured in the laboratory.\nThe absolute value of TAG is then the species tag (as given in line 2 of file.int above) and ERR is the reported experimental\nerror. integer, intent(out) :: qnfmt Identifies the format of the quantum numbers given in the field QN. integer, intent(out) :: qn (12) Twice the quantum numbers numbers. These are integers but are converted from their coding format\naccording to QNFMT. Upper state quanta start in character 1. Lower state quanta start in character 14 (element 7).\nUnused quanta are blank, quanta whose magnitude is larger than 99 or smaller than –9 are shown with alphabetic characters\nor **. Quanta between –10 and –19 are shown as a0 through a9. Similarly, –20 is b0, etc., up to –259, which is shown as z9.\nQuanta between 100 and 109 are shown as A0 through A9. Similarly, 110 is B0, etc., up to 359, which is shown as Z9. character(len=:), intent(out), allocatable :: mol integer, intent(out) :: io logical, intent(out) :: skip character(len=1), intent(in), optional :: comment_char_in","tags":"","url":"proc/cdms_readline.html"},{"title":"write_states – CDMSreader","text":"public  subroutine write_states(funit, states) Uses CDMSreader__types CDMSreader__system CDMSreader__constants Writes the states in a legible format to the designated file unit Arguments Type Intent Optional Attributes Name integer, intent(in) :: funit The file unit class( asymtop_state ), intent(in) :: states (:) The array of states","tags":"","url":"proc/write_states.html"},{"title":"find_state_number – CDMSreader","text":"public  subroutine find_state_number(state, states, i) Uses CDMSreader__system Check if the state \"state\" is in the array of states \"states\" Arguments Type Intent Optional Attributes Name class( asymtop_state ), intent(in) :: state class( asymtop_state ), intent(in), allocatable :: states (:) integer, intent(out) :: i","tags":"","url":"proc/find_state_number.html"},{"title":"sort_last_transition – CDMSreader","text":"public impure subroutine sort_last_transition(transitions) Uses CDMSreader__system Sort the last element in the array to where it should go, assuming the rest of the array is sorted Arguments Type Intent Optional Attributes Name type( asymtop_transition ), intent(inout) :: transitions (:) The array of transitions","tags":"","url":"proc/sort_last_transition.html"},{"title":"sort_last_state – CDMSreader","text":"public impure subroutine sort_last_state(states) Uses CDMSreader__system Sort the last element in the array to where it should go, assuming the rest of the array is sorted Arguments Type Intent Optional Attributes Name class( asymtop_state ), intent(inout), allocatable, target :: states (:) The array of states","tags":"","url":"proc/sort_last_state.html"},{"title":"sort_states – CDMSreader","text":"public impure subroutine sort_states(states) Uses CDMSreader__system Insertion sort the array states, without assuming that it is sorted Arguments Type Intent Optional Attributes Name class( asymtop_state ), intent(inout), allocatable, target :: states (:) The array of states","tags":"","url":"proc/sort_states.html"},{"title":"add_to – CDMSreader","text":"public interface add_to Module Procedures private module subroutine add_state_to_hfs(state, states) Add state \"state\" to the array of states \"states\" Arguments Type Intent Optional Attributes Name type( asymtop_state_hfs ), intent(in) :: state class( asymtop_state ), intent(inout), allocatable :: states (:) private module subroutine add_state_to_nohfs(state, states) Add state \"state\" to the array of states \"states\" Arguments Type Intent Optional Attributes Name type( asymtop_state_nohfs ), intent(in) :: state class( asymtop_state ), intent(inout), allocatable :: states (:) private pure module subroutine add_transition_to(transition, transitions) Add transition \"transition\" to the array of transitions \"transitions\" Arguments Type Intent Optional Attributes Name type( asymtop_transition ), intent(in) :: transition type( asymtop_transition ), intent(inout), allocatable :: transitions (:)","tags":"","url":"interface/add_to.html"},{"title":"make_asymtop_state – CDMSreader","text":"public interface make_asymtop_state Module Procedures private pure elemental module function make_asymtop_state_hfs(dN, dKa, dKc, dJ, dItot, dF, E, EinstA, sigmaA2) result(state) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dN integer, intent(in) :: dKa integer, intent(in) :: dKc integer, intent(in) :: dJ integer, intent(in) :: dItot integer, intent(in) :: dF real(kind=dp), intent(in) :: E real(kind=dp), intent(in) :: EinstA real(kind=dp), intent(in) :: sigmaA2 Return Value type( asymtop_state_hfs ) private pure elemental module function make_asymtop_state_nohfs(dN, dKa, dKc, E, EinstA, degen, sigmaA2) result(state) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dN integer, intent(in) :: dKa integer, intent(in) :: dKc real(kind=dp), intent(in) :: E real(kind=dp), intent(in) :: EinstA integer, intent(in), optional :: degen real(kind=dp), intent(in) :: sigmaA2 Return Value type( asymtop_state_nohfs )","tags":"","url":"interface/make_asymtop_state.html"},{"title":"die – CDMSreader","text":"public  subroutine die(message) Uses iso_fortran_env Stop program execution with a message Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message","tags":"","url":"proc/die.html"},{"title":"CDMSreader__readwrite – CDMSreader","text":"Subroutines public impure module subroutine CDMS_readline (funit, freq, err, EinstA, DR, ELO, GUP, TAG, qnfmt, qn, mol, io, skip, comment_char_in) Read \"cat\" file from the CDMS contents into appropriate arrays, with the capability to skip lines that are well-commented or blank\nthe comment character defaults to \"#\", but can be set to anything not in the character NUMERIC also not whitespace Arguments Type Intent Optional Attributes Name integer, intent(in) :: funit real(kind=dp), intent(out) :: freq Frequency of the line real(kind=dp), intent(out) :: err Estimated or experimental error (999.9999 indicates error is larger) real(kind=dp), intent(out) :: EinstA The Einstein A coefficient integer, intent(out) :: DR Degrees of freedom in the rotational partition function (0 for atoms, 2 for linear molecules, and 3 for nonlinear molecules) real(kind=dp), intent(out) :: ELO Lower state energy in cm–1 integer, intent(out) :: GUP Upper state degeneracy integer, intent(out) :: TAG Species tag or molecular identifier. A negative value flags that the line frequency has been measured in the laboratory.\nThe absolute value of TAG is then the species tag (as given in line 2 of file.int above) and ERR is the reported experimental\nerror. integer, intent(out) :: qnfmt Identifies the format of the quantum numbers given in the field QN. integer, intent(out) :: qn (12) Twice the quantum numbers numbers. These are integers but are converted from their coding format\naccording to QNFMT. Upper state quanta start in character 1. Lower state quanta start in character 14 (element 7).\nUnused quanta are blank, quanta whose magnitude is larger than 99 or smaller than –9 are shown with alphabetic characters\nor **. Quanta between –10 and –19 are shown as a0 through a9. Similarly, –20 is b0, etc., up to –259, which is shown as z9.\nQuanta between 100 and 109 are shown as A0 through A9. Similarly, 110 is B0, etc., up to 359, which is shown as Z9. character(len=:), intent(out), allocatable :: mol integer, intent(out) :: io logical, intent(out) :: skip character(len=1), intent(in), optional :: comment_char_in public  subroutine write_states (funit, states) Writes the states in a legible format to the designated file unit Arguments Type Intent Optional Attributes Name integer, intent(in) :: funit The file unit class( asymtop_state ), intent(in) :: states (:) The array of states","tags":"","url":"module/cdmsreader__readwrite.html"},{"title":"CDMSreader__types – CDMSreader","text":"Contains type definitions and procedures for those types Uses iso_fortran_env Variables Type Visibility Attributes Name Initial integer, public, parameter :: sp = real32 integer, public, parameter :: dp = real64 Interfaces public        interface add_to private module subroutine add_state_to_hfs(state, states) Add state \"state\" to the array of states \"states\" Arguments Type Intent Optional Attributes Name type( asymtop_state_hfs ), intent(in) :: state class( asymtop_state ), intent(inout), allocatable :: states (:) private module subroutine add_state_to_nohfs(state, states) Add state \"state\" to the array of states \"states\" Arguments Type Intent Optional Attributes Name type( asymtop_state_nohfs ), intent(in) :: state class( asymtop_state ), intent(inout), allocatable :: states (:) private pure module subroutine add_transition_to(transition, transitions) Add transition \"transition\" to the array of transitions \"transitions\" Arguments Type Intent Optional Attributes Name type( asymtop_transition ), intent(in) :: transition type( asymtop_transition ), intent(inout), allocatable :: transitions (:) public        interface make_asymtop_state private pure elemental module function make_asymtop_state_hfs(dN, dKa, dKc, dJ, dItot, dF, E, EinstA, sigmaA2) result(state) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dN integer, intent(in) :: dKa integer, intent(in) :: dKc integer, intent(in) :: dJ integer, intent(in) :: dItot integer, intent(in) :: dF real(kind=dp), intent(in) :: E real(kind=dp), intent(in) :: EinstA real(kind=dp), intent(in) :: sigmaA2 Return Value type( asymtop_state_hfs ) private pure elemental module function make_asymtop_state_nohfs(dN, dKa, dKc, E, EinstA, degen, sigmaA2) result(state) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dN integer, intent(in) :: dKa integer, intent(in) :: dKc real(kind=dp), intent(in) :: E real(kind=dp), intent(in) :: EinstA integer, intent(in), optional :: degen real(kind=dp), intent(in) :: sigmaA2 Return Value type( asymtop_state_nohfs ) Derived Types type, public, abstract :: asymtop_state Corresponds to an asymmetric top molecule defined by Q = 23 without the hyperfine splitting,\nessentially averaged over F Components Type Visibility Attributes Name Initial integer, public :: dN Twice the rotational quantum number of the molecule as a rigid rotor integer, public :: dKa Twice the approximate projection of N on the A axis integer, public :: dKc Twice the approximate projection of N on the C axis real(kind=dp), public :: E The state energy real(kind=dp), public :: EinstA The total Einstein coefficient from this state real(kind=dp), public :: sigmaA2 Uncertainty in the Einstein A coefficient squared: type, public, extends( asymtop_state ) :: asymtop_state_nohfs Already defined by asymtop state ! Components Type Visibility Attributes Name Initial integer, public :: dN Twice the rotational quantum number of the molecule as a rigid rotor integer, public :: dKa Twice the approximate projection of N on the A axis integer, public :: dKc Twice the approximate projection of N on the C axis real(kind=dp), public :: E The state energy real(kind=dp), public :: EinstA The total Einstein coefficient from this state real(kind=dp), public :: sigmaA2 Uncertainty in the Einstein A coefficient squared: integer, public :: degen The total hyperfine degeneracy of the state Σ(2F+1) type, public, extends( asymtop_state ) :: asymtop_state_hfs Corresponds to an asymmetric top molecule defined by Q = 23 with the hyperfine splitting Components Type Visibility Attributes Name Initial integer, public :: dN Twice the rotational quantum number of the molecule as a rigid rotor integer, public :: dKa Twice the approximate projection of N on the A axis integer, public :: dKc Twice the approximate projection of N on the C axis real(kind=dp), public :: E The state energy real(kind=dp), public :: EinstA The total Einstein coefficient from this state real(kind=dp), public :: sigmaA2 Uncertainty in the Einstein A coefficient squared: integer, public :: dJ Twice the total angular momentum of the rotation (N) and the electron spin (S). integer, public :: dItot Twice the nuclear spin quantum number integer, public :: dF Twice the angular momentum from the rotation and electrons (J) and the nuclear spin (I). type, public :: asymtop_transition Corresponds to a transition Components Type Visibility Attributes Name Initial type( asymtop_state_hfs ), public :: up Upper state type( asymtop_state_hfs ), public :: lo Lower stat real(kind=dp), public :: freq The frequency of the transition real(kind=dp), public :: EinstA The Einstein coefficient A real(kind=dp), public :: err The error integer, public :: dr Degrees of freedom integer, public :: gup Upper level degeneracy Subroutines public  subroutine find_state_number (state, states, i) Check if the state \"state\" is in the array of states \"states\" Arguments Type Intent Optional Attributes Name class( asymtop_state ), intent(in) :: state class( asymtop_state ), intent(in), allocatable :: states (:) integer, intent(out) :: i public impure subroutine sort_last_transition (transitions) Sort the last element in the array to where it should go, assuming the rest of the array is sorted Arguments Type Intent Optional Attributes Name type( asymtop_transition ), intent(inout) :: transitions (:) The array of transitions public impure subroutine sort_last_state (states) Sort the last element in the array to where it should go, assuming the rest of the array is sorted Arguments Type Intent Optional Attributes Name class( asymtop_state ), intent(inout), allocatable, target :: states (:) The array of states public impure subroutine sort_states (states) Insertion sort the array states, without assuming that it is sorted Arguments Type Intent Optional Attributes Name class( asymtop_state ), intent(inout), allocatable, target :: states (:) The array of states","tags":"","url":"module/cdmsreader__types.html"},{"title":"CDMSreader__constants – CDMSreader","text":"Contains special numbers and conversion factors Uses CDMSreader__types Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: au2invcm = 219474.6313710e0_dp real(kind=dp), public, parameter :: au2eV = 27.2113834e0_dp real(kind=dp), public, parameter :: c_light = 299792458 real(kind=dp), public, parameter :: invcm2Hz = c_light*1e2","tags":"","url":"module/cdmsreader__constants.html"},{"title":"CDMSreader__system – CDMSreader","text":"Subroutines public  subroutine die (message) Stop program execution with a message Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message","tags":"","url":"module/cdmsreader__system.html"},{"title":"CDMSreader__readwrite.f – CDMSreader","text":"Source Code ! ================================================================================================================================ ! module CDMSreader__readwrite implicit none private public :: CDMS_readline public :: write_states ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ---------------------------------------------------------------------------------------------------------------------------------! impure module subroutine CDMS_readline ( funit , freq , err , EinstA , dr , elo , gup , tag , qnfmt , QN , mol , io , skip , comment_char_in ) !!  Read \"cat\" file from the CDMS contents into appropriate arrays, with the capability to skip lines that are well-commented or blank !!  the comment character defaults to \"#\", but can be set to anything not in the character NUMERIC also not whitespace use CDMSreader__types , only : dp use CDMSreader__system , only : die use , intrinsic :: iso_fortran_env , only : iostat_end implicit none integer , intent ( in ) :: funit integer , intent ( out ) :: DR !! Degrees of freedom in the rotational partition function (0 for atoms, 2 for linear molecules, and 3 for nonlinear molecules) integer , intent ( out ) :: GUP !! Upper state degeneracy integer , intent ( out ) :: TAG !! Species tag or molecular identifier. A negative value flags that the line frequency has been measured in the laboratory. !! The absolute value of TAG is then the species tag (as given in line 2 of file.int above) and ERR is the reported experimental !! error. integer , intent ( out ) :: qnfmt !! Identifies the format of the quantum numbers given in the field QN. real ( dp ), intent ( out ) :: freq !! Frequency of the line real ( dp ), intent ( out ) :: err !! Estimated or experimental error (999.9999 indicates error is larger) real ( dp ), intent ( out ) :: EinstA !! The Einstein A coefficient real ( dp ), intent ( out ) :: ELO !! Lower state energy in cm–1 integer , intent ( out ) :: qn ( 12 ) !! Twice the quantum numbers numbers. These are integers but are converted from their coding format !! according to QNFMT. Upper state quanta start in character 1. Lower state quanta start in character 14 (element 7). !! Unused quanta are blank, quanta whose magnitude is larger than 99 or smaller than –9 are shown with alphabetic characters !! or **. Quanta between –10 and –19 are shown as a0 through a9. Similarly, –20 is b0, etc., up to –259, which is shown as z9. !! Quanta between 100 and 109 are shown as A0 through A9. Similarly, 110 is B0, etc., up to 359, which is shown as Z9. character (:), intent ( out ), allocatable :: mol integer , intent ( out ) :: io logical , intent ( out ) :: skip character ( 1 ), intent ( in ), optional :: comment_char_in character ( 2 ) :: qnchar ( 12 ) !! The quantum numbers as characters (this is what is read from the CDMS file) character ( 53 ), parameter :: CDMS_fmt = \"(F13.6, F11.7, F11.4, I2, F10.4, I3, I7, I4, 12A2, A)\" ! Valid for einstein coeffs character ( 13 ), parameter :: numeric = \"0123456789.+-\" character ( 65 ), parameter :: alphanumeric = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ& &abcdefghijklmnopqrstuvwxyz& &0123456789.+-\" character ( 1 ) :: comment_char integer :: commentStart integer :: alphanumericStart integer :: alphanumericEnd character ( 100 ) :: line skip = . false . ! -- set different comment character maybe comment_char = \"#\" ; if ( present ( comment_char_in )) comment_char = comment_char_in read ( funit , \"(A)\" , iostat = io ) line if ( io . eq . iostat_end ) return if ( io . ne . 0 ) call die ( \"Problem reading the line: \" // line ) ! -- avoid comments and prune the line alphanumericEnd = scan ( line , alphanumeric , . true .) ! -- find position of last  alphanumeric character commentStart = scan ( line , comment_char ) ! -- find position of first comment character if ( commentStart . gt . 0 ) then line = line ( 1 : min ( commentStart - 1 , alphanumericEnd )) ! -- prune line else line = line ( 1 : alphanumericEnd ) endif if ( commentStart . gt . 0 . AND . commentStart . lt . 1 ) skip = . true . ! -- cycle reading if the line appears commented out if ( trim ( line ) . eq . \"\" ) skip = . true . if ( skip . eqv . . true .) return allocate ( character ( 100 ) :: mol ) ! -- read into variables read ( line , CDMS_fmt ) freq , err , EinstA , dr , elo , gup , tag , qnfmt , qnchar ( 1 : 12 ), mol ! -- convert and trim output qn = charQN2int ( qnchar ) mol = trim ( mol ) end subroutine CDMS_readline ! ---------------------------------------------------------------------------------------------------------------------------------! impure elemental function charQN2int ( QNchar ) result ( res ) !! Converts the CDMS 2-character representation of integers to actual integers use CDMSreader__system , only : die implicit none character ( 2 ), intent ( in ) :: QNchar integer :: res character ( 1 ), parameter :: uppercase ( 26 ) = [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" , \"H\" , \"I\" , \"J\" , \"K\" , \"L\" , \"M\" , \"N\" , \"O\" , \"P\" , \"Q\" , \"R\" , \"S\" , \"T\" , \"U\" & , \"V\" , \"W\" , \"X\" , \"Y\" , \"Z\" ] character ( 1 ), parameter :: lowercase ( 26 ) = [ \"a\" , \"b\" , \"c\" , \"d\" , \"e\" , \"f\" , \"g\" , \"h\" , \"i\" , \"j\" , \"k\" , \"l\" , \"m\" , \"n\" , \"o\" , \"p\" , \"q\" , \"r\" , \"s\" , \"t\" , \"u\" & , \"v\" , \"w\" , \"x\" , \"y\" , \"z\" ] character ( 1 ), parameter :: integers ( 10 ) = [ \"0\" , \"1\" , \"2\" , \"3\" , \"4\" , \"5\" , \"6\" , \"7\" , \"8\" , \"9\" ] integer :: int1 , int2 ! -- first character if ( any ( QNchar ( 1 : 1 ) . eq . uppercase )) then int1 = ichar ( QNchar ( 1 : 1 )) - ichar ( \"A\" ) + 10 elseif ( any ( QNchar ( 1 : 1 ) . eq . lowercase )) then int1 = ichar ( to_uppercase ( QNchar ( 1 : 1 ))) - ichar ( \"A\" ) + 10 int1 = - int1 elseif ( QNchar ( 1 : 1 ) . eq . \" \" ) then int1 = 0 elseif ( any ( QNchar ( 1 : 1 ) . eq . integers )) then read ( QNchar ( 1 : 1 ), \"(I1)\" ) int1 else call die ( \"Could not determine the quantum number \" // QNchar ) endif ! -- second character if ( all ( QNchar ( 2 : 2 ) . ne . integers )) call die ( \"Could not determine the quantum number \" // QNchar ) read ( QNchar ( 2 : 2 ), \"(I1)\" ) int2 res = int1 * 10 + int2 contains ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental function to_uppercase ( str ) result ( res ) implicit none character ( * ), intent ( in ) :: str character ( len ( str )) :: res integer :: i , n integer :: ic res = str n = len ( res ) do i = 1 , n ic = ichar ( res ( i : i )) if ( ic . ge . 97 . AND . ic . le . 122 ) res ( i : i ) = char ( ic - 32 ) enddo end function to_uppercase end function charQN2int ! -------------------------------------------------------------------------------------------------------------------------------- ! subroutine write_states ( funit , states ) !! Writes the states in a legible format to the designated file unit use CDMSreader__types , only : asymtop_state , asymtop_state_hfs , asymtop_state_nohfs , dp use CDMSreader__system , only : die use CDMSreader__constants , only : au2ev , au2invcm implicit none integer , intent ( in ) :: funit !! The file unit class ( asymtop_state ), intent ( in ) :: states (:) !! The array of states integer :: n , i integer :: degen real ( dp ) :: E , EinstA real ( dp ) :: sigmaT character (:), allocatable :: charN , charKa , charKc , charJ , charItot , charF character ( 18 ) :: header_fmt_hfs = '(A, 6A6, A15 A15)' character ( 19 ) :: header_fmt_nohfs = '(A, 4A6, A15, A15)' character ( 16 ) :: body_fmt_hfs = '(2X, 6A6)' character ( 21 ) :: body_fmt_nohfs = '(2X, 3A6, I6)' n = size ( states , 1 ) ! -- choose appropriate header select type ( s1 => states ( 1 )) type is ( asymtop_state_hfs ) write ( funit , header_fmt_hfs ) \"# \" , \"N\" , \"Ka\" , \"Kc\" , \"J\" , \"Itot\" , \"F\" , \"energy (meV)\" , \"lifetime (s)\" type is ( asymtop_state_nohfs ) write ( funit , header_fmt_nohfs ) \"# \" , \"N\" , \"Ka\" , \"Kc\" , \"degen\" , \"energy (meV)\" , \"lifetime (s)\" class default call die ( \"Invalid type for element 1 of the states array in the write procedure\" ) end select do i = 1 , n charN = doubleint2char ( states ( i ) % dN ) charKa = doubleint2char ( states ( i ) % dKa ) charKc = doubleint2char ( states ( i ) % dKc ) E = states ( i ) % E EinstA = states ( i ) % EinstA ! -- invcm -> meV E = E / au2invcm * au2ev * 1000 ! -- print the corresponding infor for this type of state select type ( si => states ( i )) type is ( asymtop_state_nohfs ) degen = si % degen write ( funit , body_fmt_nohfs , advance = \"no\" ) charN , charKa , charKc , degen if ( E . eq . 0 . OR . E . ge . 1e-2 ) then write ( funit , '(F15.6)' , advance = \"no\" ) E else write ( funit , '(E15.6)' , advance = \"no\" ) E endif type is ( asymtop_state_hfs ) charJ = doubleint2char ( si % dJ ) charItot = doubleint2char ( si % dItot ) charF = doubleint2char ( si % dF ) write ( funit , body_fmt_hfs , advance = \"no\" ) charN , charKa , charKc , charJ , charItot , charF if ( E . eq . 0 . OR . E . ge . 1e-2 ) then write ( funit , '(F15.6)' , advance = \"no\" ) E else write ( funit , '(E15.6)' , advance = \"no\" ) E endif class default call die ( \"Invalid type detected in the states array in the write procedure\" ) end select ! -- print the lifetimes with their calculated uncertainties if ( EinstA . eq . 0 ) then write ( funit , '(A15)' ) \"inf\" else sigmaT = sqrt ( states ( i ) % sigmaA2 ) / EinstA ** 2 write ( funit , '(F15.6, \" ± \", F0.6)' ) 1 / EinstA , sigmaT endif enddo end subroutine write_states ! -------------------------------------------------------------------------------------------------------------------------------- ! pure function doubleint2char ( i ) result ( res ) !! Writes the value i/2 to a character. If i is even, write i/2 as an '(I0)'. !! If i is odd, write i/2 as '(I0, \"/\", I0)' implicit none integer , intent ( in ) :: i character (:), allocatable :: res allocate ( character ( 10 ) :: res ) if ( mod ( i , 2 ) . eq . 0 ) then write ( res , '(I0)' ) i / 2 res = trim ( res ) return endif write ( res , '(I0, \"/\", I0)' ) i , 2 res = trim ( res ) end function doubleint2char ! ================================================================================================================================ ! end module CDMSreader__readwrite ! ================================================================================================================================ !","tags":"","url":"sourcefile/cdmsreader__readwrite.f.html"},{"title":"CDMSreader__types.f – CDMSreader","text":"Source Code ! ================================================================================================================================ ! module CDMSreader__types !! Contains type definitions and procedures for those types use , intrinsic :: iso_fortran_env , only : real32 , real64 implicit none private ! -- derived types public :: asymtop_state public :: asymtop_state_hfs public :: asymtop_state_nohfs public :: asymtop_transition ! -- routines public :: sort_last_transition public :: add_to public :: find_state_number public :: sort_last_state public :: sort_states public :: make_asymtop_state integer , parameter , public :: sp = real32 integer , parameter , public :: dp = real64 type , abstract :: asymtop_state !! Corresponds to an asymmetric top molecule defined by Q = 23 without the hyperfine splitting, !! essentially averaged over F integer :: dN !! Twice the rotational quantum number of the molecule as a rigid rotor integer :: dKa !! Twice the approximate projection of N on the A axis integer :: dKc !! Twice the approximate projection of N on the C axis real ( dp ) :: E !! The state energy real ( dp ) :: EinstA !! The total Einstein coefficient from this state real ( dp ) :: sigmaA2 !! Uncertainty in the Einstein A coefficient squared: \\sigma_A&#94;2 end type asymtop_state type , extends ( asymtop_state ) :: asymtop_state_nohfs !! Already defined by asymtop state ! integer :: degen !! The total hyperfine degeneracy of the state Σ(2F+1) end type asymtop_state_nohfs type , extends ( asymtop_state ) :: asymtop_state_hfs !! Corresponds to an asymmetric top molecule defined by Q = 23 with the hyperfine splitting integer :: dJ !! Twice the total angular momentum of the rotation (N) and the electron spin (S). !! \\vec{J} = \\vec{N} + \\vec{S} integer :: dItot !! Twice the nuclear spin quantum number integer :: dF !! Twice the angular momentum from the rotation and electrons (J) and the nuclear spin (I). !! \\vec{F} = \\vec{J} + \\vec{I} =  \\vec{N} + \\vec{S} + \\vec{I}  end type asymtop_state_hfs type asymtop_transition !! Corresponds to a transition type ( asymtop_state_hfs ) :: up !! Upper state type ( asymtop_state_hfs ) :: lo !! Lower stat real ( dp ) :: freq !! The frequency of the transition real ( dp ) :: EinstA !! The Einstein coefficient A real ( dp ) :: err !! The error integer :: dr !! Degrees of freedom integer :: gup !! Upper level degeneracy end type asymtop_transition ! interface operator(.isin.) !   module procedure :: state_is_in !   module procedure :: transition_is_in ! end interface operator(.isin.) interface operator (. precedes .) module procedure :: precedes_state end interface operator (. precedes .) interface assignment ( = ) module procedure :: state_set_eq end interface assignment ( = ) interface operator (. eq .) module procedure :: state_iseq end interface operator (. eq .) interface operator (. ne .) module procedure :: state_ne end interface operator (. ne .) interface add_to ! module procedure :: add_state_to module procedure :: add_state_to_hfs module procedure :: add_state_to_nohfs module procedure :: add_transition_to end interface add_to interface make_asymtop_state module procedure :: make_asymtop_state_hfs module procedure :: make_asymtop_state_nohfs end interface make_asymtop_state contains ! ------------------------------------------------------------------------------------------------------------------------------ ! impure elemental function state_iseq ( state1 , state2 ) result ( res ) !! Checks if two states are equal use CDMSreader__system , only : die implicit none class ( asymtop_state ), intent ( in ) :: state1 class ( asymtop_state ), intent ( in ) :: state2 logical :: res res = . false . if ( state1 % dN . ne . state2 % dN ) return if ( state1 % dKa . ne . state2 % dKa ) return if ( state1 % dKc . ne . state2 % dKc ) return select type ( s1 => state1 ) type is ( asymtop_state_hfs ) select type ( s2 => state2 ) type is ( asymtop_state_hfs ) if ( s1 % dJ . ne . s2 % dJ ) return if ( s1 % dItot . ne . s2 % dItot ) return if ( s1 % dF . ne . s2 % dF ) return class default call die ( \"Trying to test equality between a hfs and non hfs state !\" ) end select end select res = . true . end function state_iseq ! ------------------------------------------------------------------------------------------------------------------------------ ! impure elemental function state_ne ( state1 , state2 ) result ( res ) !! Checks if two states are not equal implicit none class ( asymtop_state ), intent ( in ) :: state1 class ( asymtop_state ), intent ( in ) :: state2 logical :: res res = . not . ( state1 . eq . state2 ) end function state_ne ! ------------------------------------------------------------------------------------------------------------------------------ ! subroutine find_state_number ( state , states , i ) !! Check if the state \"state\" is in the array of states \"states\" use CDMSreader__system , only : die implicit none class ( asymtop_state ), intent ( in ) :: state class ( asymtop_state ), intent ( in ), allocatable :: states (:) integer , intent ( out ) :: i i = 0 if (. not . allocated ( states )) return do i = 1 , size ( states , 1 ) if ( state % dN . ne . states ( i ) % dN ) cycle if ( state % dKa . ne . states ( i ) % dKa ) cycle if ( state % dKc . ne . states ( i ) % dKc ) cycle ! -- additional criteria if we have hyperfine structure select type ( s => state ) type is ( asymtop_state_hfs ) select type ( si => states ( i )) type is ( asymtop_state_hfs ) if ( s % dJ . ne . si % dJ ) cycle if ( s % dItot . ne . si % dItot ) cycle if ( s % dF . ne . si % dF ) cycle class default call die ( \"Trying to find an hfs state in an array of non hfs states !\" ) end select end select return enddo i = 0 end subroutine find_state_number ! ------------------------------------------------------------------------------------------------------------------------------ ! impure function state_is_in ( state , states ) result ( res ) !! Check if the state \"state\" is in the array of states \"states\" implicit none class ( asymtop_state ), intent ( in ) :: state class ( asymtop_state ), intent ( in ), allocatable :: states (:) logical :: res integer :: i res = . false . if (. not . allocated ( states )) return do i = 1 , size ( states , 1 ) if ( state . ne . states ( i )) cycle res = . true . return enddo end function state_is_in ! ------------------------------------------------------------------------------------------------------------------------------ ! impure function transition_is_in ( transition , transitions ) result ( res ) !! Check if the transition \"transition\" is in the array of transitions \"transitions\" implicit none type ( asymtop_transition ), intent ( in ) :: transition type ( asymtop_transition ), intent ( in ), allocatable :: transitions (:) logical :: res integer :: i res = . false . if (. not . allocated ( transitions )) return do i = 1 , size ( transitions , 1 ) if ( transition % up . ne . transitions ( i ) % up ) cycle if ( transition % lo . ne . transitions ( i ) % lo ) cycle res = . true . return enddo end function transition_is_in ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine add_state_to_hfs ( state , states ) !! Add state \"state\" to the array of states \"states\" implicit none type ( asymtop_state_hfs ), intent ( in ) :: state class ( asymtop_state ), intent ( inout ), allocatable :: states (:) class ( asymtop_state ), allocatable :: tmp (:) integer :: n if (. not . allocated ( states )) then allocate ( states ( 1 ), source = state ) states ( 1 ) = state else n = size ( states , 1 ) call move_alloc ( states , tmp ) allocate ( states ( n + 1 ), source = state ) states ( 1 : n ) = tmp ( 1 : n ) states ( n + 1 ) = state deallocate ( tmp ) endif end subroutine add_state_to_hfs ! ------------------------------------------------------------------------------------------------------------------------------ ! module subroutine add_state_to_nohfs ( state , states ) !! Add state \"state\" to the array of states \"states\" implicit none type ( asymtop_state_nohfs ), intent ( in ) :: state class ( asymtop_state ), intent ( inout ), allocatable :: states (:) class ( asymtop_state ), allocatable :: tmp (:) integer :: n if (. not . allocated ( states )) then allocate ( states ( 1 ), source = state ) states ( 1 ) = state return endif n = size ( states , 1 ) call move_alloc ( states , tmp ) allocate ( states ( n + 1 ), source = state ) states ( 1 : n ) = tmp ( 1 : n ) states ( n + 1 ) = state deallocate ( tmp ) end subroutine add_state_to_nohfs ! ------------------------------------------------------------------------------------------------------------------------------ ! pure module subroutine add_transition_to ( transition , transitions ) !! Add transition \"transition\" to the array of transitions \"transitions\" implicit none type ( asymtop_transition ), intent ( in ) :: transition type ( asymtop_transition ), intent ( inout ), allocatable :: transitions (:) if (. not . allocated ( transitions )) then transitions = [ transition ] else transitions = [ transitions , transition ] endif end subroutine add_transition_to ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental function precedes_state ( state1 , state2 ) result ( res ) !! Test whether state 1 precedes state 2 in the arbitrary sorting of states by !! J, Ka, Kc, J, Itot, and finally F implicit none class ( asymtop_state ), intent ( in ) :: state1 class ( asymtop_state ), intent ( in ) :: state2 logical :: res res = . true . if ( state1 % E . lt . state2 % E ) return res = . false . end function precedes_state ! ------------------------------------------------------------------------------------------------------------------------------ ! impure subroutine sort_last_transition ( transitions ) !! Sort the last element in the array to where it should go, assuming the rest of the array is sorted use CDMSreader__system , only : die implicit none type ( asymtop_transition ), intent ( inout ) :: transitions (:) !! The array of transitions integer :: i , k , n type ( asymtop_transition ) :: last n = size ( transitions , 1 ) last = transitions ( n ) i = findloc ( ( last % lo . precedes . transitions ( 1 : n - 1 ) % lo ) & . AND . ( last % up . precedes . transitions ( 1 : n - 1 ) % up ) & , value = . true . & , dim = 1 & ) select case ( i ) case (: - 1 ) call die ( \"Findloc returned a negative index in transition sort !\" ) case ( 0 ) ! -- locical mask is all .false. ; last is last return case ( 1 ) ! -- locical mask is all .true. ; last is first transitions = [ last , transitions ( 1 : n - 1 )] case default transitions = [ transitions ( 1 : i - 1 ), last , transitions ( i : n - 1 )] end select end subroutine sort_last_transition ! ------------------------------------------------------------------------------------------------------------------------------ ! impure subroutine sort_last_state ( states ) !! Sort the last element in the array to where it should go, assuming the rest of the array is sorted use CDMSreader__system , only : die implicit none class ( asymtop_state ), intent ( inout ), allocatable , target :: states (:) !! The array of states class ( asymtop_state ), allocatable :: last class ( asymtop_state ), allocatable :: tmp (:) integer :: i , k , n n = size ( states , 1 ) allocate ( last , source = states ( n )) last = states ( n ) i = findloc ( ( last . precedes . states ( 1 : n - 1 )), value = . true ., dim = 1 ) select case ( i ) case (: - 1 ) call die ( \"Findloc returned a negative index in state sort !\" ) case ( 0 ) ! -- locical mask is all .false. ; last is last return case ( 1 ) ! -- locical mask is all .true. ; last is first call move_alloc ( states , tmp ) allocate ( states ( n ), source = last ) states ( 1 ) = last states ( 2 : n ) = tmp ( 1 : n - 1 ) deallocate ( tmp ) case default call move_alloc ( states , tmp ) allocate ( states ( n ), source = last ) states ( 1 : i - 1 ) = tmp ( 1 : i - 1 ) states ( i ) = last states ( i + 1 : n ) = tmp ( i : n - 1 ) deallocate ( tmp ) end select if ( n . ne . size ( states )) call die ( \"The size of the states array has changed during the sort !\" ) end subroutine sort_last_state ! ------------------------------------------------------------------------------------------------------------------------------ ! impure subroutine sort_states ( states ) !! Insertion sort the array states, without assuming that it is sorted use CDMSreader__system , only : die implicit none class ( asymtop_state ), intent ( inout ), allocatable , target :: states (:) !! The array of states class ( asymtop_state ), allocatable :: state class ( asymtop_state ), allocatable :: tmp (:) integer :: i , k , n , pos n = size ( states , 1 ) allocate ( state , source = states ( n )) allocate ( tmp ( n ), source = states ( n )) tmp ( 1 ) = states ( 1 ) outer : do i = 2 , n state = states ( i ) pos = i inner : do k = i - 1 , 1 , - 1 if ( state . precedes . tmp ( k )) then tmp ( k + 1 ) = tmp ( k ) pos = k cycle inner end if exit inner enddo inner tmp ( pos ) = state enddo outer call move_alloc ( tmp , states ) end subroutine sort_states ! ------------------------------------------------------------------------------------------------------------------------------ ! impure elemental subroutine swap_state ( state1 , state2 ) implicit none class ( asymtop_state ), intent ( inout ) :: state1 , state2 class ( asymtop_state ), allocatable :: tmp call state_set_eq ( tmp , state1 ) call state_set_eq ( state1 , state2 ) call state_set_eq ( state2 , tmp ) deallocate ( tmp ) end subroutine swap_state ! ------------------------------------------------------------------------------------------------------------------------------ ! impure elemental subroutine state_set_eq ( state1 , state2 ) !! Define assignment for two abstract asymtop states use CDMSreader__system , only : die implicit none class ( asymtop_state ), intent ( out ) :: state1 class ( asymtop_state ), intent ( in ) :: state2 state1 % dN = state2 % dN state1 % dKa = state2 % dKa state1 % dKc = state2 % dKc state1 % E = state2 % E state1 % EinstA = state2 % EinstA state1 % sigmaA2 = state2 % sigmaA2 select type ( s1 => state1 ) ! -- two hfs states type is ( asymtop_state_hfs ) select type ( s2 => state2 ) type is ( asymtop_state_hfs ) s1 % dJ = s2 % dJ s1 % dItot = s2 % dItot s1 % dF = s2 % dF class default call die ( \"Attempting to assign an hfs state to a non hfs state !\" ) end select ! -- two non hfs states type is ( asymtop_state_nohfs ) select type ( s2 => state2 ) type is ( asymtop_state_nohfs ) s1 % degen = s2 % degen class default call die ( \"Attempting to assign a non hfs state to an hfs state !\" ) end select end select end subroutine state_set_eq ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function make_asymtop_state_hfs ( dN , dKa , dKc , dJ , dItot , dF , E , EinstA , sigmaA2 ) result ( state ) implicit none integer , intent ( in ) :: dN , dKa , dKc , dJ , dItot , dF real ( dp ), intent ( in ) :: E , EinstA , sigmaA2 type ( asymtop_state_hfs ) :: state state % dN = dN state % dKa = dKa state % dKc = dKc state % dJ = dJ state % dItot = dItot state % dF = dF state % E = E state % EinstA = EinstA state % sigmaA2 = sigmaA2 end function make_asymtop_state_hfs ! ------------------------------------------------------------------------------------------------------------------------------ ! pure elemental module function make_asymtop_state_nohfs ( dN , dKa , dKc , E , EinstA , degen , sigmaA2 ) result ( state ) implicit none integer , intent ( in ) :: dN , dKa , dKc integer , intent ( in ), optional :: degen real ( dp ), intent ( in ) :: E , EinstA , sigmaA2 type ( asymtop_state_nohfs ) :: state state % dN = dN state % dKa = dKa state % dKc = dKc state % E = E state % EinstA = EinstA state % sigmaA2 = sigmaA2 if (. true . . eqv . present ( degen )) then state % degen = degen else state % degen = 0 endif end function make_asymtop_state_nohfs end module CDMSreader__types ! ================================================================================================================================ !","tags":"","url":"sourcefile/cdmsreader__types.f.html"},{"title":"CDMSreader__constants.f – CDMSreader","text":"Source Code ! ================================================================================================================================ ! module CDMSreader__constants !! Contains special numbers and conversion factors use CDMSreader__types , only : dp implicit none private real ( dp ), parameter , public :: au2invcm = 21947 4.6313710e0_dp ! -- atomic units -> inverse centimeters real ( dp ), parameter , public :: au2eV = 2 7.2113834e0_dp ! -- atomic units -> electron volts real ( dp ), parameter , public :: c_light = 299792458 ! -- speed of light in m/s real ( dp ), parameter , public :: invcm2Hz = c_light * 1e2 ! -- inverse centimeters -> Hz ! ================================================================================================================================ ! end module CDMSreader__constants ! ================================================================================================================================ !","tags":"","url":"sourcefile/cdmsreader__constants.f.html"},{"title":"CDMSreader__system.f – CDMSreader","text":"Source Code ! ================================================================================================================================ ! module CDMSreader__system ! ================================================================================================================================ ! implicit none private public :: die ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! -------------------------------------------------------------------------------------------------------------------------------- ! subroutine die ( message ) !! Stop program execution with a message use , intrinsic :: iso_fortran_env , only : stderr => error_unit implicit none character ( * ), intent ( in ), optional :: message write ( stderr , * ) write ( stderr , '(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\")' ) write ( stderr , '(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\")' ) write ( stderr , '(\"@@@@                                                           @@@@\")' ) write ( stderr , '(\"@@@@                          ERROR                            @@@@\")' ) write ( stderr , '(\"@@@@                                                           @@@@\")' ) write ( stderr , '(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\")' ) write ( stderr , '(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\")' ) write ( stderr , * ) if (. not . present ( message )) error stop write ( stderr , '(\"STOP\",X,\"::\",X,A)' ) message write ( stderr , * ) error stop end subroutine die ! ================================================================================================================================ ! end module CDMSreader__system ! ================================================================================================================================ !","tags":"","url":"sourcefile/cdmsreader__system.f.html"}]}