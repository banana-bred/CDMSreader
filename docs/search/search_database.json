var tipuesearch = {"pages":[{"title":" Fortran Program ","text":"Fortran Program CDMSreader Reads molecular transition data from the Cologne Database for Molecular Spectroscopy ( CDMS ) catalogue\nto determine the radiative lifetimes of the various states involved in the transitions.\nThe data must be obtained in the proper format by using the search and conversion form .\nThe user should ask for values with the intensities being given as log values.\nUnits can be in GHz or inverse centimeters. For now, this only works for one molecule at a time and only for asymmetric top molecules that correspond to the case of (see the CDMS general documentation for more details). Two sets of output data are produced.\nThe first set contains the lifetimes for the states with the quantum number , the second does a statistical average over . Docs available here . Todo: [ ] Add more state types, generalize the types module [ ] Organize the types module into submodules for better clarity [ ] Add other state types corresponding to different Qs [ ] Add the ability to work with different isotopologues/molecules at once so that we can just use one file Determining the liftimes of excited states. Atoms and molecules can be found in excited states in various media, but these excited states have finite lifetimes because they spontaneously decause to lower-lying states.\nThe ground state is only stable because there is no lower state to which the system could decay on its own.\nWhen an atom/molecule spontaneously decays, it emits radiation as a way of cooling, so to speak.\nThe Einstein A coefficients describe the probability per unit time that the atom/molecule in level will spontaneously decay to level , emitting a photon of frequency .\nThe probability per unit time that the system decays into any of the available lower states is just given by the sum of the Einstein A coefficients for transitions starting from that state: We can then take the invese of this to get the average lifetime of a specific state, . The CDMS search and conversion form already does the work of determining the Einstein A coefficients.\nThis code just reads several transitions, determines which states are involved, and then just adds the Einstein A coefficients for the corresponding state to determine the lifetimes.\nYou can add headers to the file or stream containing the transitions so long as they're commented with # .\nThe format is very delicate, so make sure not to alter the transition lines. Installation This is available as a Fortran Package Manager ( fpm ) package, so it can just be built with the usual build command in the cloned repository fpm build The package can be built without fpm .\nOn linux, just use the provided compile script.\nOther compilers than gfortran will probably work just fine. Usage The program expects to read transitions from standard input, so you can just feed it in like so: ./CDMSreader < transitions.dat > lifetimes.txt or even with fpm if you built the program that way fpm run < transitions.dat > lifetimes.txt","tags":"home","url":"index.html"},{"title":"charQN2int – Fortran Program","text":"elemental function charQN2int(QNchar) result(res) Uses CDMSreader__system Converts the CDMS 2-character representation of integers to actual integers Arguments Type Intent Optional Attributes Name real :: QNchar Return Value real","tags":"","url":"proc/charqn2int.html"},{"title":"CDMSreader__readwrite.f – Fortran Program","text":"Read \"cat\" file from the CDMS contents into appropriate arrays, with the capability to skip lines that are well-commented or blank\n the comment character defaults to \"#\", but can be set to anything not in the character NUMERIC also not whitespace Degrees of freedom in the rotational partition function (0 for atoms, 2 for linear molecules, and 3 for nonlinear molecules)\nUpper state degeneracy\nSpecies tag or molecular identifier. A negative value flags that the line frequency has been measured in the laboratory.\nThe absolute value of TAG is then the species tag (as given in line 2 of file.int above) and ERR is the reported experimental\nerror.\nIdentifies the format of the quantum numbers given in the field QN.\nFrequency of the line\nEstimated or experimental error (999.9999 indicates error is larger)\nThe Einstein A coefficient\nLower state energy in cm–1\nTwice the quantum numbers numbers. These are integers but are converted from their coding format\naccording to QNFMT. Upper state quanta start in character 1. Lower state quanta start in character 14 (element 7).\nUnused quanta are blank, quanta whose magnitude is larger than 99 or smaller than –9 are shown with alphabetic characters\nor **. Quanta between –10 and –19 are shown as a0 through a9. Similarly, –20 is b0, etc., up to –259, which is shown as z9.\nQuanta between 100 and 109 are shown as A0 through A9. Similarly, 110 is B0, etc., up to 359, which is shown as Z9.\nThe quantum numbers as characters (this is what is read from the CDMS file) Writes the states in a legible format to the designated file unit\nThe file unit\nThe array of states Writes the value i/2 to a character. If i is even, write i/2 as an '(I0)'.\nIf i is odd, write i/2 as '(I0, \"/\", I0)' Source Code ! ================================================================================================================================ ! modul e CDMSreader__readwrite imp l icit none pri v ate pub l ic :: CDMS_readline pub l ic :: write_states ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! ---------------------------------------------------------------------------------------------------------------------------------! impur e module subroutine CDMS_readline ( funit , freq , err , EinstA , dr , elo , gup, tag, qnfmt, QN, mol, io, skip, comment_char_in) !!  Read \"cat\" file from the CDMS contents into appropriate arrays, with the capability to skip lines that are well-commented or blank !!  the comment character defaults to \"#\", but can be set to anything not in the character NUMERIC also not whitespace use CDMSreader__types , only : dp use CDMSreader__system , only : die use , intrinsic :: iso_fortran_env , only : iostat_end imp l icit none int e ger , intent ( in ) :: funit int e ger , intent ( out ) :: DR !! Degrees of freedom in the rotational partition function (0 for atoms, 2 for linear molecules, and 3 for nonlinear molecules) int e ger , intent ( out ) :: GUP !! Upper state degeneracy int e ger , intent ( out ) :: TAG !! Species tag or molecular identifier. A negative value flags that the line frequency has been measured in the laboratory. !! The absolute value of TAG is then the species tag (as given in line 2 of file.int above) and ERR is the reported experimental !! error. int e ger , intent ( out ) :: qnfmt !! Identifies the format of the quantum numbers given in the field QN. rea l ( dp ), intent ( out ) :: freq !! Frequency of the line rea l ( dp ), intent ( out ) :: err !! Estimated or experimental error (999.9999 indicates error is larger) rea l ( dp ), intent ( out ) :: EinstA !! The Einstein A coefficient rea l ( dp ), intent ( out ) :: ELO !! Lower state energy in cm–1 int e ger , intent ( out ) :: qn ( 12 ) !! Twice the quantum numbers numbers. These are integers but are converted from their coding format !! according to QNFMT. Upper state quanta start in character 1. Lower state quanta start in character 14 (element 7). !! Unused quanta are blank, quanta whose magnitude is larger than 99 or smaller than –9 are shown with alphabetic characters !! or **. Quanta between –10 and –19 are shown as a0 through a9. Similarly, –20 is b0, etc., up to –259, which is shown as z9. !! Quanta between 100 and 109 are shown as A0 through A9. Similarly, 110 is B0, etc., up to 359, which is shown as Z9. cha r acter (:), intent ( out ), allocatable :: mol int e ger , intent ( out ) :: io log i cal , intent ( out ) :: skip cha r acter ( 1 ), intent ( in ), optional :: comment_char_in cha r acter ( 2 ) :: qnchar ( 12 ) !! The quantum numbers as characters (this is what is read from the CDMS file) cha r acter ( 53 ), parameter :: CDMS_fmt = \" ( F13 . 6 , F11 . 7 , F11 . 4 , I2 , F10 . 4, I3, I7, I4, 12A2, A)\" ! Valid for einstein coeffs cha r acter ( 13 ), parameter :: numeric = \"0123456789.+-\" cha r acter ( 65 ), parameter :: alphanumeric = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ & & abcdefghijklmnopqrstuvwxyz & & 012345678 9. +- \" cha r acter ( 1 ) :: comment_char int e ger :: commentStart int e ger :: alphanumericStart int e ger :: alphanumericEnd cha r acter ( 100 ) :: line ski p = . false . ! -- set different comment character maybe com m ent_char = \"#\" ; if ( present ( comment_char_in )) comment_char = comme nt_char_in rea d ( funit , \"(A)\" , iostat = io ) line if( i o . eq . iostat_end ) return if( i o . ne . 0 ) call die ( \"Problem reading the line: \" // line ) ! -- avoid comments and prune the line alp h anumericEnd = scan ( line , alphanumeric , . true .) ! -- find position of last  alphanumeric character com m entStart = scan ( line , comment_char ) ! -- find position of first comment character if( c ommentStart . gt . 0 ) then l i ne = line ( 1 : min ( commentStart - 1 , alphanumericEnd )) ! -- prune line els e l i ne = line ( 1 : alphanumericEnd ) end i f if( c ommentStart . gt . 0 . AND . commentStart . lt . 1 ) skip = . true . ! -- cycle reading if the line appears commented out if( t rim ( line ) . eq . \"\" ) skip = . true . if( s kip . eqv . . true .) return all o cate ( character ( 100 ) :: mol ) ! -- read into variables rea d ( line , CDMS_fmt ) freq , err , EinstA , dr , elo , gup , tag , qnfmt , qnch ar(1:12), mol ! -- convert and trim output qn = charQN2int ( qnchar ) mol = trim ( mol ) end s u broutine CDMS_readline ! ---------------------------------------------------------------------------------------------------------------------------------! impur e elemental function charQN2int ( QNchar ) result ( res ) !! Converts the CDMS 2-character representation of integers to actual integers use CDMSreader__system , only : die imp l icit none cha r acter ( 2 ), intent ( in ) :: QNchar int e ger :: res cha r acter ( 1 ), parameter :: uppercase ( 26 ) = [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \" G \",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\"& , \"V\" , \"W\" , \"X\" , \"Y\" , \"Z\" ] cha r acter ( 1 ), parameter :: lowercase ( 26 ) = [ \"a\" , \"b\" , \"c\" , \"d\" , \"e\" , \"f\" , \" g \",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\"& , \"v\" , \"w\" , \"x\" , \"y\" , \"z\" ] cha r acter ( 1 ), parameter :: integers ( 10 ) = [ \"0\" , \"1\" , \"2\" , \"3\" , \"4\" , \"5\" , \"6\" ,\"7\",\"8\",\"9\"] int e ger :: int1 , int2 ! -- first character if( a ny ( QNchar ( 1 : 1 ) . eq . uppercase )) then i n t1 = ichar ( QNchar ( 1 : 1 )) - ichar ( \"A\" ) + 10 els e if ( any ( QNchar ( 1 : 1 ) . eq . lowercase )) then i n t1 = ichar ( to_uppercase ( QNchar ( 1 : 1 ))) - ichar ( \"A\" ) + 10 i n t1 = - int1 els e if ( QNchar ( 1 : 1 ) . eq . \" \" ) then i n t1 = 0 els e if ( any ( QNchar ( 1 : 1 ) . eq . integers )) then r e ad ( QNchar ( 1 : 1 ), \"(I1)\" ) int1 els e c a ll die ( \"Could not determine the quantum number \" // QNchar ) end i f ! -- second character if( a ll ( QNchar ( 2 : 2 ) . ne . integers )) call die ( \" Could not determine the quantum number \" // QNchar) rea d ( QNchar ( 2 : 2 ), \"(I1)\" ) int2 res = int1 * 10 + int2 contains ! ------------------------------------------------------------------------------------------------------------------------------ ! pur e elemental function to_uppercase ( str ) result ( res ) i m plicit none c h aracter ( * ), intent ( in ) :: str c h aracter ( len ( str )) :: res i n teger :: i , n i n teger :: ic r e s = str n = len ( res ) d o i = 1 , n ic = ichar ( res ( i : i )) if ( ic . ge . 97 . AND . ic . le . 122 ) res ( i : i ) = char ( ic - 32 ) e n ddo end function to_uppercase end f u nction charQN2int ! -------------------------------------------------------------------------------------------------------------------------------- ! subro u tine write_states ( funit , states ) !! Writes the states in a legible format to the designated file unit use CDMSreader__types , only : asymtop_state , asymtop_state_hfs , asy mtop_state_nohfs, dp use CDMSreader__system , only : die use CDMSreader__constants , only : au2ev , au2invcm imp l icit none int e ger , intent ( in ) :: funit !! The file unit cla s s ( asymtop_state ), intent ( in ) :: states (:) !! The array of states int e ger :: n , i int e ger :: degen rea l ( dp ) :: E , EinstA rea l ( dp ) :: sigmaT cha r acter (:), allocatable :: charN , charKa , charKc , charJ , charItot , c harF cha r acter ( 18 ) :: header_fmt_hfs = '(A, 6A6, A15 A15)' cha r acter ( 19 ) :: header_fmt_nohfs = '(A, 4A6, A15, A15)' cha r acter ( 16 ) :: body_fmt_hfs = '(2X, 6A6)' cha r acter ( 21 ) :: body_fmt_nohfs = '(2X, 3A6, I6)' n = size ( states , 1 ) ! -- choose appropriate header sel e ct type ( s1 => states ( 1 )) typ e is ( asymtop_state_hfs ) w r ite ( funit , header_fmt_hfs ) \"# \" , \"N\" , \"Ka\" , \"Kc\" , \"J\" , \"Itot\" , \"F\" , \"energy (meV)\", \"lifetime (s)\" typ e is ( asymtop_state_nohfs ) w r ite ( funit , header_fmt_nohfs ) \"# \" , \"N\" , \"Ka\" , \"Kc\" , \"degen\" , \" ener gy (meV)\", \"lifetime (s)\" cla s s default c a ll die ( \" Invalid type for element 1 of the states array in the writ e procedure\") end select do i = 1 , n c h arN = doubleint2char ( states ( i ) % dN ) c h arKa = doubleint2char ( states ( i ) % dKa ) c h arKc = doubleint2char ( states ( i ) % dKc ) E = states ( i ) % E E i nstA = states ( i ) % EinstA ! -- invcm -> meV E = E / au2invcm * au2ev * 1000 ! -- print the corresponding infor for this type of state s e lect type ( si => states ( i )) t y pe is ( asymtop_state_nohfs ) degen = si % degen write ( funit , body_fmt_nohfs , advance = \"no\" ) charN , charKa , charKc , degen if ( E . eq . 0 . OR . E . ge . 1e-2 ) then write ( funit , '(F15.6)' , advance = \"no\" ) E else write ( funit , '(E15.6)' , advance = \"no\" ) E endif t y pe is ( asymtop_state_hfs ) charJ = doubleint2char ( si % dJ ) charItot = doubleint2char ( si % dItot ) charF = doubleint2char ( si % dF ) write ( funit , body_fmt_hfs , advance = \"no\" ) charN , charKa , charKc , charJ, charItot, charF if ( E . eq . 0 . OR . E . ge . 1e-2 ) then write ( funit , '(F15.6)' , advance = \"no\" ) E else write ( funit , '(E15.6)' , advance = \"no\" ) E endif c l ass default call die ( \" Invalid type detected in the states array in the write p rocedure\") e n d select ! -- print the lifetimes with their calculated uncertainties i f ( EinstA . eq . 0 ) then write ( funit , '(A15)' ) \"inf\" e l se sigmaT = sqrt ( states ( i ) % sigmaA2 ) / EinstA ** 2 write ( funit , '(F15.6, \" ± \", F0.6)' ) 1 / EinstA , sigmaT e n dif end d o end s u broutine write_states ! -------------------------------------------------------------------------------------------------------------------------------- ! pure f unction doubleint2char ( i ) result ( res ) !! Writes the value i/2 to a character. If i is even, write i/2 as an '(I0)'. !! If i is odd, write i/2 as '(I0, \"/\", I0)' imp l icit none int e ger , intent ( in ) :: i cha r acter (:), allocatable :: res all o cate ( character ( 10 ) :: res ) if( m od ( i , 2 ) . eq . 0 ) then w r ite ( res , '(I0)' ) i / 2 r e s = trim ( res ) r e turn end i f wri t e ( res , '(I0, \"/\", I0)' ) i , 2 res = trim ( res ) end f u nction doubleint2char ! ================================================================================================================================ ! end m o dule CDMSreader__readwrite ! ================================================================================================================================ !","tags":"","url":"sourcefile/cdmsreader__readwrite.f.html"},{"title":"CDMSreader__system.f – Fortran Program","text":"Stop program execution with a message Source Code ! ================================================================================================================================ ! modul e CDMSreader__system ! ================================================================================================================================ ! imp l icit none pri v ate pub l ic :: die ! ================================================================================================================================ ! contains ! ================================================================================================================================ ! ! -------------------------------------------------------------------------------------------------------------------------------- ! subro u tine die ( message ) !! Stop program execution with a message use , intrinsic :: iso_fortran_env , only : stderr => error_unit imp l icit none cha r acter ( * ), intent ( in ), optional :: message wri t e ( stderr , * ) wri t e ( stderr , ' ( \"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@\")') wri t e ( stderr , ' ( \"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@\")') wri t e ( stderr , ' ( \"@@@@ @@@@\")') wri t e ( stderr , ' ( \"@@@@ ERROR @@@@\")') wri t e ( stderr , ' ( \"@@@@ @@@@\")') wri t e ( stderr , ' ( \"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@\")') wri t e ( stderr , ' ( \"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@\")') wri t e ( stderr , * ) if( . not . present ( message )) error stop wri t e ( stderr , '(\"STOP\",X,\"::\",X,A)' ) message wri t e ( stderr , * ) err o r stop end s u broutine die ! ================================================================================================================================ ! end m o dule CDMSreader__system ! ================================================================================================================================ !","tags":"","url":"sourcefile/cdmsreader__system.f.html"},{"title":"CDMSreader__constants.f – Fortran Program","text":"Contains special numbers and conversion factors Source Code ! ================================================================================================================================ ! modul e CDMSreader__constants !! Contains special numbers and conversion factors use CDMSreader__types , only : dp imp l icit none pri v ate rea l ( dp ), parameter , public :: au2invcm = 21947 4.6313710e0_dp ! -- atomic units -> inverse centimeters rea l ( dp ), parameter , public :: au2eV = 2 7.2113834e0_dp ! -- atomic units -> electron volts rea l ( dp ), parameter , public :: c_light = 299792458 ! -- speed of light in m/s rea l ( dp ), parameter , public :: invcm2Hz = c_light * 1e2 ! -- inverse centimeters -> Hz ! ================================================================================================================================ ! end m o dule CDMSreader__constants ! ================================================================================================================================ !","tags":"","url":"sourcefile/cdmsreader__constants.f.html"}]}